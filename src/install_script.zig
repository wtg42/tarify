const std = @import("std");

/// Options for transforming INSTALL.sh content.
/// - backup_list: list of files/dirs to back up (strings will be emitted into the generated block)
/// - newline: line separator to use in output ("\n", "\r\n", etc.)
pub const ModifyOptions = struct {
    backup_list: []const []const u8,
    newline: []const u8,
};

/// Transform INSTALL.sh content into a standardized form.
/// TDD plan: initial stub returns original content; tests will require:
/// - truncating and regenerating content after a marker block
/// - inserting backup commands for each path in backup_list
pub fn modifyInstallScriptContent(
    allocator: std.mem.Allocator,
    original: []const u8,
    opts: ModifyOptions,
) ![]u8 {
    const nl = opts.newline;
    const marker = "# WEB UPDATE START";

    var out = std.ArrayList(u8){};
    defer out.deinit(allocator);

    if (std.mem.indexOf(u8, original, marker)) |idx| {
        // Keep everything up to the marker, drop the rest, and regenerate block
        try out.appendSlice(allocator, original[0..idx]);
        try out.appendSlice(allocator, marker);
        try out.appendSlice(allocator, nl);
    } else {
        // No marker: keep original and add a new block at the end
        try out.appendSlice(allocator, original);
        if (original.len == 0 or !std.mem.endsWith(u8, original, nl)) {
            try out.appendSlice(allocator, nl);
        }
        try out.appendSlice(allocator, marker);
        try out.appendSlice(allocator, nl);
    }

    // Generate backup list block. We only need to include paths so tests can assert their presence.
    // Real implementation can add commands like tar/rsync with --ignore-failed-read.
    // Header (optional)
    try out.appendSlice(allocator, "# AUTOGENERATED BACKUP LIST");
    try out.appendSlice(allocator, nl);
    for (opts.backup_list) |p| {
        try out.appendSlice(allocator, p);
        try out.appendSlice(allocator, nl);
    }
    try out.appendSlice(allocator, "# WEB UPDATE END");
    try out.appendSlice(allocator, nl);

    return out.toOwnedSlice(allocator);
}
